/*
 * Copyright 2001-2015 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalatest.prop

/*
I need to know how many or at least what percentage of edges I should
produce. When I map and flatmap I want it to combine edges and regulars
both. What if instead of T, we filled two buckets, and instead of just
a size, we also pass in how many of each we want?
Or, how about an Rng for edge conditions, and I just hmm. Yes that might
work. If I have 7 edges, then I want a random number from 0 to 6 and
I pick from the edges. Yes, so my edges could be a thing on Gen, which
also gets mapped and flatMapped? Do I have a number of them? Or do I not
worry about that. Probably just don't worry about it.
Edges[T] {
  can have map and flatmap on it
}
*/
// (size: Int, randomNumGen: Rnd) => (value, new randomNumGen)
// def yeOldeNext(size: Int = 10, rnd: Rnd = Rnd.default()): (T, Rnd, Gen[T]) = next(size, rnd)
abstract class Gen[+T](val rnd: Rnd) { thisGenOfT =>
  def next(size: Int = 100): (T, Gen[T])
  final def map[U](f: T => U): Gen[U] =
    new Gen[U](rnd) {
      def next(size: Int): (U, Gen[U]) = {
        val (nextValue, nextGenOfT) = thisGenOfT.next(size)
        (f(nextValue), nextGenOfT.map(f))
      }
    }
  final def flatMap[U](f: T => Gen[U]): Gen[U] = {
    val (_, nextGenOfT) = thisGenOfT.next(100)
    new Gen[U](nextGenOfT.rnd) {
      def next(size: Int): (U, Gen[U]) = {
        val (nextT, nextGenOfT) = thisGenOfT.next(100)
        (f(nextT).next(size)._1, nextGenOfT.flatMap(f))
      }
    }
  }
/*
    new Gen[U](rnd) {
/*
This changed my doubles
      def next(size: Int): (U, Gen[U]) = {
        val (nextT, nextGenOfT) = thisGenOfT.next(size)
        // val nextGenOfU: Gen[U] = nextGenOfT.flatMap(f) // f(nextT)// .next(size)._1
        val nextU = f(nextT).next(size)._1
        val nextGenOfU = f(nextT).next(size)._2
        (nextU, nextGenOfU)// nextGenOfT.flatMap(f))
      }
*/
      def next(size: Int): (U, Gen[U]) = {
        val tup = thisGenOfT.next(size)
        val nextT: T = tup._1
        val nextGenOfT: Gen[T] = tup._2
        val fOfNextU: Gen[U] = f(nextT) // Need this to get the map to work, the chained ones.
        val nextGenOfU: Gen[U] = nextGenOfT.flatMap(u => fOfNextU)
        val nextU = f(nextT).next(size)._1
        // val nextGenOfU: Gen[U] = nextGenOfT.flatMap(f) // f(nextT)// .next(size)._1
        // val nextGenOfU = f(nextT).next(size)._2 // This changes my ints, th emapped one, but doubles, the flatMapped ones don't change
        // val nextGenOfU = nextGenOfT.flatMap(f) // This changes my doubles, the flatMapped one, but ints, the mapped ones don't change
        // val nextGenOfU = f(nextT).flatMap(f).next(size)._2
        (nextU, f(nextGenOfT.next(size)._1)) // nextGenOfT.flatMap(f))
      }
    }
*/
}

object Gen {
  private final class IntGen(passedRnd: Rnd) extends Gen[Int](passedRnd) { thisGen =>
    def next(size: Int): (Int, Gen[Int]) = {
      val (nextValue, nextRnd) = rnd.nextInt
      (nextValue, new IntGen(nextRnd))
    }
  }
  def intGen(rnd: Rnd): Gen[Int] = new IntGen(rnd)
  implicit def intGenDefault(): Gen[Int] = intGen(Rnd.default)

  private final class DoubleGen(passedRnd: Rnd) extends Gen[Double](passedRnd) { thisGen =>
    def next(size: Int): (Double, Gen[Double]) = {
      val (nextValue, nextRnd) = rnd.nextDouble
      (nextValue, new DoubleGen(nextRnd))
    }
  }
  def doubleGen(rnd: Rnd): Gen[Double] = new DoubleGen(rnd)
  implicit def doubleGenDefault(): Gen[Double] = doubleGen(Rnd.default)
}

